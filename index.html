<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">
<link rel="manifest" href="manifest.json">
<title>Textarea</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html {
    color-scheme: light dark;
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;

    background-color: #fff;
    --elevated: #fff;
    --link: #0066cc;
    --text: #161616;
    --outline: #007aff;

    @media (prefers-color-scheme: dark) {
      background-color: #000;
      --elevated: #121212;
      --link: #58a6ff;
      --text: #fff;
    }
  }

  /* ── Layout ── */
  body {
    display: flex;
    color: var(--text);
  }

  #main {
    flex: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
    transition: margin-right 0.3s ease;
  }

  body.sidebar-collapsed #main {
    margin-right: 44px;
    /* width of collapsed bar */
  }

  /* ── Title & Article ── */
  #title-input {
    width: 100%;
    border: none;
    outline: none;
    font: 2em / 1.2 system-ui;
    font-weight: 700;
    padding: 24px 40px 0;
    background: transparent;
    color: var(--text);
  }

  article {
    outline: none;
    padding: 12px 40px 40px;
    width: 100%;
    min-height: calc(100dvh - 4em);
    font: 18px / 1.5 system-ui;
    tab-size: 4;
    white-space: pre-wrap;
    text-wrap-style: stable;
    overflow-wrap: break-word;
  }

  /* ── Sidebar ── */
  #sidebar {
    position: fixed;
    top: 0;
    right: 0;
    width: 280px;
    height: 100dvh;
    background: var(--elevated);
    border-left: 1px solid rgba(0, 0, 0, 0.1);
    display: flex;
    flex-direction: column;
    z-index: 10;
    transition: width 0.25s ease;
    overflow: hidden;
  }

  @media (prefers-color-scheme: dark) {
    #sidebar {
      border-left: 1px solid rgba(255, 255, 255, 0.08);
    }
  }

  body.sidebar-collapsed #sidebar {
    width: 44px;
  }

  /* reserve space for the sidebar so main content doesn't go under */
  body:not(.sidebar-collapsed) #main {
    margin-right: 280px;
  }

  /* Sidebar header row */
  #sidebar-header {
    display: flex;
    align-items: center;
    padding: 10px 8px;
    gap: 4px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.08);
    flex-shrink: 0;
  }

  @media (prefers-color-scheme: dark) {
    #sidebar-header {
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    }
  }

  #sidebar-toggle {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text);
    padding: 6px;
    border-radius: 6px;
    display: grid;
    place-items: center;
    flex-shrink: 0;
  }

  #sidebar-toggle:hover {
    background: rgba(0, 0, 0, 0.06);
  }

  @media (prefers-color-scheme: dark) {
    #sidebar-toggle:hover {
      background: rgba(255, 255, 255, 0.08);
    }
  }

  #sidebar-title {
    font-weight: 600;
    font-size: 15px;
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    opacity: 1;
    transition: opacity 0.2s;
  }

  body.sidebar-collapsed #sidebar-title {
    opacity: 0;
    pointer-events: none;
  }

  /* Sidebar body (hidden when collapsed) */
  #sidebar-body {
    flex: 1;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 0;
    opacity: 1;
    transition: opacity 0.15s;
  }

  body.sidebar-collapsed #sidebar-body {
    opacity: 0;
    pointer-events: none;
  }

  /* ── Settings section inside sidebar ── */
  #settings-section {
    padding: 12px 14px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.08);
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  @media (prefers-color-scheme: dark) {
    #settings-section {
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    }
  }

  #settings-toggle {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text);
    display: flex;
    align-items: center;
    gap: 8px;
    font: 14px / 1 system-ui;
    font-weight: 600;
    padding: 4px 0;
    width: 100%;
  }

  #settings-toggle svg {
    flex-shrink: 0;
  }

  #settings-body {
    display: none;
    flex-direction: column;
    gap: 10px;
  }

  #settings-body.open {
    display: flex;
  }

  .settings-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .settings-label {
    font-size: 12px;
    font-weight: 600;
    opacity: 0.6;
    text-transform: uppercase;
    letter-spacing: 0.04em;
  }

  .settings-input {
    width: 100%;
    padding: 6px 8px;
    border: 1px solid rgba(0, 0, 0, 0.15);
    border-radius: 6px;
    background: transparent;
    color: var(--text);
    font: 13px system-ui;
  }

  @media (prefers-color-scheme: dark) {
    .settings-input {
      border: 1px solid rgba(255, 255, 255, 0.15);
    }
  }

  .settings-btn {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 7px 10px;
    border-radius: 7px;
    border: none;
    background: rgba(0, 0, 0, 0.05);
    color: var(--text);
    cursor: pointer;
    font: 13px system-ui;
    text-decoration: none;
    transition: background 0.15s;
  }

  .settings-btn:hover {
    background: rgba(0, 0, 0, 0.1);
  }

  @media (prefers-color-scheme: dark) {
    .settings-btn {
      background: rgba(255, 255, 255, 0.06);
    }

    .settings-btn:hover {
      background: rgba(255, 255, 255, 0.12);
    }
  }

  /* ── Actions (new doc) ── */
  #sidebar-actions {
    padding: 12px 14px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.08);
  }

  @media (prefers-color-scheme: dark) {
    #sidebar-actions {
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    }
  }

  /* ── History ── */
  #sidebar-history {
    padding: 12px 14px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    flex: 1;
  }

  #sidebar-history h3 {
    font-size: 12px;
    font-weight: 600;
    opacity: 0.6;
    text-transform: uppercase;
    letter-spacing: 0.04em;
  }

  #history-list {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .history-item {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding: 8px 10px;
    border-radius: 8px;
    background: rgba(0, 0, 0, 0.04);
    text-decoration: none;
    color: var(--text);
    transition: background 0.15s;
  }

  .history-item:hover {
    background: rgba(0, 0, 0, 0.09);
  }

  @media (prefers-color-scheme: dark) {
    .history-item {
      background: rgba(255, 255, 255, 0.05);
    }

    .history-item:hover {
      background: rgba(255, 255, 255, 0.1);
    }
  }

  .history-item-content {
    display: flex;
    flex-direction: column;
    flex: 1;
    min-width: 0;
  }

  .history-item-title {
    font-weight: 600;
    font-size: 13px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .history-item-time {
    font-size: 11px;
    opacity: 0.55;
    margin-top: 2px;
  }

  .history-item-copy {
    background: transparent;
    border: none;
    color: var(--text);
    cursor: pointer;
    opacity: 0.4;
    transition: opacity 0.15s;
    padding: 3px;
    margin-left: 6px;
    display: flex;
    align-items: center;
    border-radius: 4px;
    flex-shrink: 0;
  }

  .history-item-copy:hover {
    opacity: 1;
  }

  /* ── Notification ── */
  #notification {
    visibility: hidden;
    transform: translateY(-30px);
    transition: all 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
    opacity: 0;
    position: fixed;
    left: 50%;
    transform: translateX(-50%) translateY(-30px);
    top: 17px;
    background: #5ad227;
    color: #fff;
    border-radius: 30px;
    font: 15px / 1 system-ui;
    font-weight: 600;
    z-index: 100;
    padding: 9px 18px;
  }

  #notification.visible {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
    visibility: visible;
  }

  @media print {
    .noprint {
      visibility: hidden !important;
    }
  }

  .md-h1,
  .md-h2,
  .md-h3,
  .md-h4,
  .md-h5,
  .md-h6 {
    font-weight: 700;
  }

  .md-h1 {
    font-size: 2em;
  }

  .md-h2 {
    font-size: 1.5em;
  }

  .md-h3 {
    font-size: 1.25em;
  }

  .md-h4 {
    font-size: 1.1em;
  }

  .md-h5 {
    font-size: 1em;
  }

  .md-h6 {
    font-size: 0.9em;
  }

  .md-code,
  .md-codeblock {
    font-family: monospace;
  }

  .md-bold {
    font-weight: bold;
  }

  .md-strike {
    text-decoration: line-through;
  }

  .md-italic {
    font-style: italic;
  }

  .md-url {
    cursor: pointer;
  }

  a {
    color: var(--link);
    text-decoration: underline;
    text-underline-offset: 4px;
    text-decoration-thickness: 1px;
  }

  /* ── Status bar ── */
  #status-bar {
    position: fixed;
    bottom: 0;
    left: 0;
    padding: 5px 40px;
    font-size: 12px;
    opacity: 0.45;
    display: flex;
    align-items: center;
    gap: 12px;
    user-select: none;
    pointer-events: none;
  }

  /* ── Autosave indicator ── */
  #save-dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    background: #5ad227;
    opacity: 0;
    transition: opacity 0.3s;
    flex-shrink: 0;
  }

  #save-dot.flash {
    opacity: 1;
  }

  /* ── History search ── */
  #history-search {
    width: 100%;
    padding: 5px 8px;
    border: 1px solid rgba(0, 0, 0, 0.12);
    border-radius: 6px;
    background: transparent;
    color: var(--text);
    font: 13px system-ui;
    outline: none;
  }

  @media (prefers-color-scheme: dark) {
    #history-search {
      border: 1px solid rgba(255, 255, 255, 0.12);
    }
  }

  /* ── Active history item ── */
  .history-item.current {
    border-left: 3px solid var(--outline);
    padding-left: 7px;
  }

  /* ── Empty history state ── */
  #history-empty {
    font-size: 13px;
    opacity: 0.45;
    text-align: center;
    padding: 20px 0;
  }

  /* ── Editor wrapper (gutter + article) ── */
  #editor-wrap {
    display: flex;
    flex: 1;
    min-height: calc(100dvh - 3.6em);
  }

  /* ── Line number gutter ── */
  #gutter {
    width: 44px;
    padding: 12px 8px 40px 0;
    text-align: right;
    font: 18px / 1.5 system-ui;
    color: var(--text);
    opacity: 0.25;
    user-select: none;
    pointer-events: none;
    flex-shrink: 0;
    overflow: hidden;
  }

  #gutter div {
    height: 1.5em;
  }

  /* patch article left padding to sit next to gutter */
  article {
    padding-left: 12px !important;
  }

  /* ── In-doc search bar ── */
  #find-bar {
    display: none;
    position: fixed;
    top: 12px;
    right: 310px;
    /* clear the sidebar */
    z-index: 20;
    background: var(--elevated);
    border: 1px solid rgba(0, 0, 0, 0.15);
    border-radius: 8px;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.12);
    padding: 6px 10px;
    display: none;
    align-items: center;
    gap: 8px;
    min-width: 280px;
  }

  @media (prefers-color-scheme: dark) {
    #find-bar {
      border: 1px solid rgba(255, 255, 255, 0.12);
    }
  }

  #find-bar.open {
    display: flex;
  }

  #find-input {
    flex: 1;
    border: none;
    outline: none;
    background: transparent;
    color: var(--text);
    font: 14px system-ui;
  }

  #find-count {
    font-size: 12px;
    opacity: 0.5;
    white-space: nowrap;
    flex-shrink: 0;
  }

  #find-prev,
  #find-next,
  #find-close {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text);
    opacity: 0.6;
    padding: 2px 4px;
    border-radius: 4px;
    font-size: 14px;
    line-height: 1;
  }

  #find-prev:hover,
  #find-next:hover,
  #find-close:hover {
    opacity: 1;
  }

  /* CSS Custom Highlight for search matches */
  ::highlight(find-match) {
    background-color: rgba(255, 200, 0, 0.45);
    color: inherit;
  }

  ::highlight(find-match-current) {
    background-color: rgba(255, 140, 0, 0.7);
    color: inherit;
  }
</style>
<div id="main">
  <input id="title-input" placeholder="Title" spellcheck="false" autocomplete="off" autofocus />
  <div id="editor-wrap">
    <div id="gutter"></div>
    <article contenteditable="plaintext-only" spellcheck></article>
  </div>
  <div id="status-bar" class="noprint">
    <span id="save-dot"></span>
    <span id="word-count">0 words</span>
    <span id="char-count">0 chars</span>
    <span id="ln-col">Ln 1, Col 1</span>
  </div>
</div>
<div id="find-bar" class="noprint">
  <input id="find-input" placeholder="Search or :12 to jump to line" />
  <span id="find-count"></span>
  <button id="find-prev" title="Previous (Shift+Enter)">&#8593;</button>
  <button id="find-next" title="Next (Enter)">&#8595;</button>
  <button id="find-close" title="Close (Esc)">&#x2715;</button>
</div>
<aside id="sidebar" class="noprint">
  <div id="sidebar-header">
    <button id="sidebar-toggle" aria-label="Toggle Sidebar">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
        stroke-linecap="round" stroke-linejoin="round">
        <line x1="3" y1="12" x2="21" y2="12"></line>
        <line x1="3" y1="6" x2="21" y2="6"></line>
        <line x1="3" y1="18" x2="21" y2="18"></line>
      </svg>
    </button>
    <span id="sidebar-title">TextArea</span>
  </div>
  <div id="sidebar-body">
    <!-- Settings Section -->
    <div id="settings-section">
      <button id="settings-toggle">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="3"></circle>
          <path
            d="M12 1v2m0 18v2M4.22 4.22l1.42 1.42m12.72 12.72l1.42 1.42M1 12h2m18 0h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42">
          </path>
        </svg>
        Settings
      </button>
      <div id="settings-body">
        <div class="settings-group">
          <span class="settings-label">Short.io Link Shortening</span>
          <input class="settings-input" type="text" id="short-io-domain" placeholder="Domain (e.g. link.domain.com)" />
          <input class="settings-input" type="password" id="short-io-key" placeholder="Short.io Secret Key" />
        </div>
        <a class="settings-btn" id="qr" href="qr.html">
          <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="3" width="7" height="7"></rect>
            <rect x="14" y="3" width="7" height="7"></rect>
            <rect x="14" y="14" width="7" height="7"></rect>
            <rect x="3" y="14" width="7" height="7"></rect>
          </svg>
          Generate QR Code
        </a>
        <button class="settings-btn" id="save-as-html">Save as HTML</button>
        <button class="settings-btn" id="save-as-text">Save as TEXT</button>
        <a class="settings-btn" href="https://github.com/antonmedv/textarea" target="_blank">GitHub</a>
        <button class="settings-btn" id="clear-all-storage" style="color:#e04f4f;margin-top:4px">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round">
            <polyline points="3 6 5 6 21 6"></polyline>
            <path d="M19 6l-1 14H6L5 6"></path>
            <path d="M10 11v6M14 11v6"></path>
            <path d="M9 6V4h6v2"></path>
          </svg>
          Clear All Data
        </button>
      </div>
    </div>

    <!-- New Doc Action -->
    <div id="sidebar-actions">
      <button class="settings-btn" id="new-browser-tab" style="width:100%;justify-content:center">
        <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
          <line x1="12" y1="5" x2="12" y2="19"></line>
          <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
        New (cmd+shift+.)
      </button>
    </div>

    <!-- History -->
    <div id="sidebar-history">
      <h3>Recent Documents</h3>
      <input id="history-search" placeholder="Search..." />
      <div id="history-list"></div>
    </div>
  </div>
</aside>
<div id="notification" class="noprint"></div>
<script>
  initUI()

  const article = document.querySelector('article')
  const titleInput = document.querySelector('#title-input')
  const editor = new Editor(article, parseMarkdown)

  const saveAndDebounce = debounce(500, save)
  article.addEventListener('input', saveAndDebounce)
  titleInput.addEventListener('input', saveAndDebounce)

  article.addEventListener('blur', save)
  titleInput.addEventListener('blur', save)

  // Enter on title jumps to content
  titleInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      e.preventDefault()
      article.focus()
    }
  })

  // Live word + char count
  const wordCountEl = document.querySelector('#word-count')
  const charCountEl = document.querySelector('#char-count')
  const saveDot = document.querySelector('#save-dot')
  let saveDotTimer = null

  // Live word + char count
  const lnColEl = document.querySelector('#ln-col')
  const gutterEl = document.querySelector('#gutter')

  function updateStats() {
    const text = article.textContent
    const words = text.trim() ? text.trim().split(/\s+/).length : 0
    wordCountEl.textContent = words + (words === 1 ? ' word' : ' words')
    charCountEl.textContent = text.length + (text.length === 1 ? ' char' : ' chars')
    updateGutter(text)
  }

  function updateGutter(text) {
    gutterEl.innerHTML = ''
    const count = (text || '').split('\n').length
    for (let i = 1; i <= count; i++) {
      const d = document.createElement('div')
      d.textContent = i
      gutterEl.appendChild(d)
    }
  }

  function updateLnCol() {
    const sel = window.getSelection()
    if (!sel || !sel.rangeCount) return
    const range = sel.getRangeAt(0)
    // Walk back through text to count lines
    const preRange = document.createRange()
    preRange.setStart(article, 0)
    preRange.setEnd(range.startContainer, range.startOffset)
    const pre = preRange.toString()
    const ln = (pre.match(/\n/g) || []).length + 1
    const col = pre.length - pre.lastIndexOf('\n')
    lnColEl.textContent = `Ln ${ln}, Col ${col}`
  }

  article.addEventListener('input', updateStats)
  article.addEventListener('keyup', updateLnCol)
  article.addEventListener('mouseup', updateLnCol)
  updateStats()

  // ── In-document Find ──────────────────────────────────────
  const findBar = document.querySelector('#find-bar')
  const findInput = document.querySelector('#find-input')
  const findCount = document.querySelector('#find-count')
  const findPrev = document.querySelector('#find-prev')
  const findNext = document.querySelector('#find-next')
  const findClose = document.querySelector('#find-close')

  let findMatches = []
  let findIndex = 0
  const supportsHighlight = typeof CSS !== 'undefined' && CSS.highlights

  function getAllTextNodes(el) {
    const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT)
    const nodes = []
    let n
    while ((n = walker.nextNode())) nodes.push(n)
    return nodes
  }

  function runFind(query) {
    if (supportsHighlight) {
      CSS.highlights.delete('find-match')
      CSS.highlights.delete('find-match-current')
    }
    findMatches = []
    findCount.textContent = ''
    if (!query) return

    // :N → go to line N
    const lineMatch = query.match(/^:(\d+)$/)
    if (lineMatch) {
      const targetLine = parseInt(lineMatch[1], 10)
      const textNodes = getAllTextNodes(article)
      let linesSeen = 1
      for (const node of textNodes) {
        const parts = node.textContent.split('\n')
        for (let i = 0; i < parts.length; i++) {
          if (linesSeen === targetLine) {
            const range = document.createRange()
            const offset = parts.slice(0, i).join('\n').length + (i > 0 ? 1 : 0)
            try {
              range.setStart(node, Math.min(offset, node.textContent.length))
              range.collapse(true)
              const sel = window.getSelection()
              sel.removeAllRanges()
              sel.addRange(range)
              // Find and scroll to a gutter line div
              const gutterLine = gutterEl.children[targetLine - 1]
              if (gutterLine) gutterLine.scrollIntoView({ block: 'center' })
              findCount.textContent = `Line ${targetLine}`
            } catch (e) { }
            return
          }
          if (i < parts.length - 1) linesSeen++
        }
      }
      findCount.textContent = 'Line not found'
      return
    }

    // Text search
    const textNodes = getAllTextNodes(article)
    const ranges = []
    for (const node of textNodes) {
      const text = node.textContent
      const lower = text.toLowerCase()
      const q = query.toLowerCase()
      let idx = 0
      while ((idx = lower.indexOf(q, idx)) !== -1) {
        const range = document.createRange()
        range.setStart(node, idx)
        range.setEnd(node, idx + query.length)
        ranges.push(range)
        idx += query.length
      }
    }
    findMatches = ranges
    if (ranges.length === 0) {
      findCount.textContent = 'No results'
      return
    }
    findIndex = -1
    if (supportsHighlight) {
      CSS.highlights.set('find-match', new Highlight(...ranges))
    }
    // highlight only — do NOT steal cursor focus
    findCount.textContent = `${ranges.length} match${ranges.length === 1 ? '' : 'es'}`
    // Scroll first match into view without changing selection
    try {
      ranges[0].startContainer.parentElement?.scrollIntoView({ block: 'nearest', behavior: 'smooth' })
    } catch (e) { }
  }

  function scrollToMatch(idx) {
    if (!findMatches.length) return
    findIndex = ((idx % findMatches.length) + findMatches.length) % findMatches.length
    const range = findMatches[findIndex]
    findCount.textContent = `${findIndex + 1} / ${findMatches.length}`
    if (supportsHighlight) {
      CSS.highlights.set('find-match-current', new Highlight(range))
    }
    // Scroll the match into the center of the viewport without touching the cursor
    const rect = range.getBoundingClientRect()
    const target = window.scrollY + rect.top - window.innerHeight / 2
    window.scrollTo({ top: target, behavior: 'smooth' })
  }

  function openFind() {
    findBar.classList.add('open')
    findInput.focus()
    findInput.select()
  }

  function closeFind() {
    findBar.classList.remove('open')
    if (supportsHighlight) {
      CSS.highlights.delete('find-match')
      CSS.highlights.delete('find-match-current')
    }
    findMatches = []
    findCount.textContent = ''
    article.focus()
  }

  findInput.addEventListener('input', e => runFind(e.target.value.trim()))
  findInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') { e.preventDefault(); scrollToMatch(e.shiftKey ? findIndex - 1 : findIndex + 1) }
    if (e.key === 'Escape') closeFind()
  })
  findNext.addEventListener('click', () => scrollToMatch(findIndex + 1))
  findPrev.addEventListener('click', () => scrollToMatch(findIndex - 1))
  findClose.addEventListener('click', closeFind)

  article.addEventListener('click', event => {
    if (event.target.tagName === 'A') window.open(event.target.getAttribute('href'), '_blank')
  })

  addEventListener('hashchange', load)
  addEventListener('DOMContentLoaded', load)
  addEventListener('load', () => new MutationObserver(save).observe(article, { attributeFilter: ['style'] }))

  function openNewDoc() {
    const a = Object.assign(document.createElement('a'), {
      href: location.pathname + '#new',
      target: '_blank',
      rel: 'noopener'
    })
    document.body.appendChild(a)
    a.click()
    a.remove()
  }

  addEventListener('keydown', e => {
    if (e.metaKey || e.ctrlKey) {
      if (e.code === 'KeyS') {
        e.preventDefault()
        downloadHTML()
      }
      if (e.code === 'KeyF') {
        e.preventDefault()
        openFind()
      }
      // Cmd/Ctrl+Shift+. — new document (not reserved by Chrome)
      if (e.shiftKey && e.code === 'Period') {
        e.preventDefault()
        openNewDoc()
      }
    }
  })

  // Wire new-browser-tab button to same helper
  document.querySelector('#new-browser-tab').addEventListener('click', openNewDoc)

  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js')
  }

  // Short.io Setup
  const shortIoDomain = document.querySelector('#short-io-domain')
  const shortIoKey = document.querySelector('#short-io-key')

  if (localStorage.getItem('shortIoDomain')) shortIoDomain.value = localStorage.getItem('shortIoDomain')
  if (localStorage.getItem('shortIoKey')) shortIoKey.value = localStorage.getItem('shortIoKey')

  shortIoDomain.addEventListener('input', () => localStorage.setItem('shortIoDomain', shortIoDomain.value))
  shortIoKey.addEventListener('input', () => localStorage.setItem('shortIoKey', shortIoKey.value))

  // Baked-in defaults injected at deploy time — users can override in Settings
  const DEFAULT_SHORTIO_DOMAIN = '__SHORTIO_DOMAIN__'
  const DEFAULT_SHORTIO_KEY = '__SHORTIO_KEY__'

  if (!DEFAULT_SHORTIO_DOMAIN.startsWith('__')) {
    shortIoDomain.placeholder = `Default: ${DEFAULT_SHORTIO_DOMAIN}`
  }
  if (!DEFAULT_SHORTIO_KEY.startsWith('__')) {
    shortIoKey.placeholder = 'Default key is active'
  }

  async function getShortUrl(longUrl) {
    // User's own credentials take priority; fall back to deploy-time defaults
    const domain = shortIoDomain.value.trim()
      || (DEFAULT_SHORTIO_DOMAIN.startsWith('__') ? '' : DEFAULT_SHORTIO_DOMAIN)
    const key = shortIoKey.value.trim()
      || (DEFAULT_SHORTIO_KEY.startsWith('__') ? '' : DEFAULT_SHORTIO_KEY)

    if (!domain || !key) return longUrl

    try {
      const response = await fetch('/api/links', {
        method: 'POST',
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json',
          'Authorization': key
        },
        body: JSON.stringify({
          domain: domain,
          originalURL: longUrl
        })
      })
      const data = await response.json()
      // Short.io returns secureShortURL for HTTPS, shortURL for HTTP
      if (data.secureShortURL) return data.secureShortURL
      if (data.shortURL) return data.shortURL
      // Surface API errors so the user knows what went wrong
      if (data.error) {
        notify('Short.io: ' + data.error)
        console.error('Short.io error:', data)
      }
    } catch (e) {
      notify('Short.io unavailable')
      console.error('Short.io fetch failed:', e)
    }
    return longUrl
  }

  function fallbackCopyTextToClipboard(text) {
    const textArea = document.createElement("textarea");
    textArea.value = text;

    // Avoid scrolling to bottom
    textArea.style.top = "0";
    textArea.style.left = "0";
    textArea.style.position = "fixed";

    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();

    try {
      document.execCommand('copy');
      notify('Link copied');
    } catch (err) {
      notify('Failed to copy');
      console.error('Fallback: Oops, unable to copy', err);
    }

    document.body.removeChild(textArea);
  }

  async function shareDocument() {
    notify('Generating link...')
    const urlToShare = await getShortUrl(location.href)

    if (navigator.clipboard) {
      try {
        await navigator.clipboard.writeText(urlToShare)
        notify('Link copied')
      } catch (err) {
        fallbackCopyTextToClipboard(urlToShare)
      }
    } else {
      fallbackCopyTextToClipboard(urlToShare)
    }
  }

  console.log('%cGitHub https://github.com/antonmedv/textarea', 'font-size: 16px; border: 1px solid lightblue; border-radius: 12px; padding: 10px 14px; ')

  let currentDocId = null;

  async function load() {
    // #new means the user explicitly wants a blank document
    if (location.hash === '#new') {
      history.replaceState({}, '', location.pathname)
      currentDocId = crypto.randomUUID()
      editor.set('')
      titleInput.value = ''
      article.removeAttribute('style')
      updateTitle()
      return
    }

    const hashToLookup = location.hash

    let foundDocId = null
    if (hashToLookup !== '') {
      try {
        const docs = JSON.parse(localStorage.getItem('doc_history_v3')) || {}
        for (const [id, doc] of Object.entries(docs)) {
          if (doc.hash === hashToLookup) {
            foundDocId = id
            break
          }
        }
      } catch (e) { }
    }

    currentDocId = foundDocId || crypto.randomUUID()

    try {
      if (hashToLookup !== '') {
        await set(hashToLookup)
      } else {
        // No hash — restore last session
        const savedHash = localStorage.getItem('hash') ?? ''
        if (savedHash) {
          await set(savedHash)
          history.replaceState({}, '', savedHash)
        } else {
          editor.set('')
          titleInput.value = ''
          article.removeAttribute('style')
        }
      }
    } catch (e) {
      editor.set('')
      titleInput.value = ''
      article.removeAttribute('style')
    }

    updateTitle()

    // Auto-import shared links into history
    const title = titleInput.value.trim()
    if (title && hashToLookup && !foundDocId) {
      updateDocsHistory(hashToLookup, title)
    }

    // Refresh gutter and counts after content is loaded
    updateStats()
  }

  async function save() {
    const hash = await get()
    if (location.hash !== hash) history.replaceState({}, '', hash)

    try {
      localStorage.setItem('hash', hash)
    } catch (e) { }

    // Flash the autosave dot
    saveDot.classList.add('flash')
    clearTimeout(saveDotTimer)
    saveDotTimer = setTimeout(() => saveDot.classList.remove('flash'), 1200)

    updateTitle()
    const title = titleInput.value.trim()
    if (title) {
      updateDocsHistory(hash, title)
    }
  }

  // Document History Management
  function updateDocsHistory(hash, title) {
    if (!hash || hash === '#' || !title) return
    let docs = {}
    try {
      docs = JSON.parse(localStorage.getItem('doc_history_v3')) || {}
    } catch (e) { }

    if (!currentDocId) currentDocId = crypto.randomUUID();

    docs[currentDocId] = {
      hash,
      title,
      timestamp: Date.now()
    }

    // Sort and limit to 50
    const sortedIds = Object.keys(docs).sort((a, b) => docs[b].timestamp - docs[a].timestamp).slice(0, 50)
    const newDocs = {}
    for (const id of sortedIds) {
      newDocs[id] = docs[id]
    }
    localStorage.setItem('doc_history_v3', JSON.stringify(newDocs))
    renderHistory()
  }

  function relativeTime(ts) {
    const diff = Date.now() - ts
    const m = Math.floor(diff / 60000)
    if (m < 1) return 'just now'
    if (m < 60) return m + 'm ago'
    const h = Math.floor(m / 60)
    if (h < 24) return h + 'h ago'
    const d = Math.floor(h / 24)
    if (d < 7) return d + 'd ago'
    return new Date(ts).toLocaleDateString()
  }

  function renderHistory(query = '') {
    const list = document.querySelector('#history-list')
    list.innerHTML = ''
    try {
      const docs = JSON.parse(localStorage.getItem('doc_history_v3')) || {}
      const sortedIds = Object.keys(docs).sort((a, b) => docs[b].timestamp - docs[a].timestamp)
      const currentHash = location.hash

      const filtered = query
        ? sortedIds.filter(id => docs[id].title.toLowerCase().includes(query.toLowerCase()))
        : sortedIds

      if (filtered.length === 0) {
        const empty = document.createElement('p')
        empty.id = 'history-empty'
        empty.textContent = query ? 'No results' : 'No documents yet'
        list.appendChild(empty)
        return
      }

      for (const id of filtered) {
        const item = docs[id]
        const a = document.createElement('a')
        a.href = item.hash
        a.className = 'history-item' + (item.hash === currentHash ? ' current' : '')

        const contentDiv = document.createElement('div')
        contentDiv.className = 'history-item-content'

        const titleSpan = document.createElement('span')
        titleSpan.className = 'history-item-title'
        titleSpan.textContent = item.title

        const timeSpan = document.createElement('span')
        timeSpan.className = 'history-item-time'
        timeSpan.textContent = relativeTime(item.timestamp)
        timeSpan.title = new Date(item.timestamp).toLocaleString()

        contentDiv.appendChild(titleSpan)
        contentDiv.appendChild(timeSpan)
        a.appendChild(contentDiv)

        const copyBtn = document.createElement('button')
        copyBtn.className = 'history-item-copy'
        copyBtn.title = 'Copy Share Link'
        copyBtn.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
        `
        const fullUrl = location.origin + location.pathname + item.hash
        copyBtn.addEventListener('click', async (e) => {
          e.preventDefault()
          e.stopPropagation()
          notify('Generating link...')
          const shareUrl = await getShortUrl(fullUrl)
          if (navigator.clipboard) {
            try { await navigator.clipboard.writeText(shareUrl); notify('Link copied') }
            catch (err) { fallbackCopyTextToClipboard(shareUrl) }
          } else { fallbackCopyTextToClipboard(shareUrl) }
        })
        a.appendChild(copyBtn)

        const delBtn = document.createElement('button')
        delBtn.className = 'history-item-copy'
        delBtn.title = 'Delete from history'
        delBtn.innerHTML = `
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="3 6 5 6 21 6"></polyline>
            <path d="M19 6l-1 14H6L5 6"></path>
            <path d="M10 11v6M14 11v6"></path>
            <path d="M9 6V4h6v2"></path>
          </svg>
        `
        delBtn.addEventListener('click', (e) => {
          e.preventDefault()
          e.stopPropagation()
          try {
            const docs = JSON.parse(localStorage.getItem('doc_history_v3')) || {}
            delete docs[id]
            localStorage.setItem('doc_history_v3', JSON.stringify(docs))
          } catch (e) { }
          renderHistory(document.querySelector('#history-search')?.value || '')
        })
        a.appendChild(delBtn)
        list.appendChild(a)
      }
    } catch (e) { }
  }

  // History search filter
  document.querySelector('#history-search').addEventListener('input', e => {
    renderHistory(e.target.value)
  })

  // Sidebar collapse toggle
  const sidebarToggle = document.querySelector('#sidebar-toggle')
  sidebarToggle.addEventListener('click', () => {
    const collapsed = document.body.classList.toggle('sidebar-collapsed')
    localStorage.setItem('sidebar_collapsed', collapsed ? '1' : '0')
    if (!collapsed) renderHistory()
  })

  // Restore sidebar collapsed state
  if (localStorage.getItem('sidebar_collapsed') === '1') {
    document.body.classList.add('sidebar-collapsed')
  } else {
    renderHistory()
  }

  // Settings accordion
  const settingsToggle = document.querySelector('#settings-toggle')
  const settingsBody = document.querySelector('#settings-body')
  settingsToggle.addEventListener('click', () => {
    settingsBody.classList.toggle('open')
  })


  // Save as HTML / TEXT wired up here
  document.querySelector('#save-as-html').addEventListener('click', downloadHTML)
  document.querySelector('#save-as-text').addEventListener('click', downloadTXT)

  // QR link stays href but needs current hash
  const qrLink = document.querySelector('#qr')
  const updateQR = () => qrLink.setAttribute('href', 'qr.html' + location.hash)
  updateQR()
  addEventListener('hashchange', updateQR)

  // Clear All Data button
  document.querySelector('#clear-all-storage').addEventListener('click', () => {
    if (confirm('Delete all saved documents and settings? This cannot be undone.')) {
      localStorage.clear()
      location.href = location.pathname  // strip hash so load() starts blank
    }
  })

  async function set(hash) {
    if (!hash) return
    const [content, style] = (await decompress(hash.slice(1))).split('\x00')

    // Extract title if present
    const match = content.match(/^\n*# (.+)\n([\s\S]*)$/)
    if (match) {
      titleInput.value = match[1]
      editor.set(match[2])
    } else {
      titleInput.value = ''
      editor.set(content)
    }

    if (style) article.setAttribute('style', style)
  }

  async function get() {
    const style = article.getAttribute('style')

    let textContent = article.textContent
    if (titleInput.value.trim() !== '') {
      textContent = `# ${titleInput.value}\n${textContent}`
    }

    const content = textContent + (style !== null ? '\x00' + style : '')
    return '#' + await compress(content)
  }

  function updateTitle() {
    document.title = titleInput.value.trim() || 'Textarea'
  }

  async function compress(string) {
    const byteArray = new TextEncoder().encode(string)
    const stream = new CompressionStream('deflate-raw')
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new Uint8Array(buffer).toBase64({ alphabet: 'base64url' })
  }

  async function decompress(b64) {
    const byteArray = Uint8Array.fromBase64(b64, { alphabet: 'base64url' })
    const stream = new DecompressionStream('deflate-raw')
    const writer = stream.writable.getWriter()
    writer.write(byteArray)
    writer.close()
    const buffer = await new Response(stream.readable).arrayBuffer()
    return new TextDecoder().decode(buffer)
  }

  function debounce(ms, fn) {
    let timer
    return (...args) => {
      clearTimeout(timer)
      timer = setTimeout(() => fn(...args), ms)
    }
  }

  async function downloadHTML() {
    updateTitle()
    const doc = document.documentElement.cloneNode(true)
    doc.querySelectorAll('script').forEach(s => s.remove())
    doc.querySelectorAll('.noprint').forEach(s => s.remove())
    doc.querySelector('article').removeAttribute('contenteditable')
    const html = '<!DOCTYPE html>\n' + doc.outerHTML

    if ('showSaveFilePicker' in window) {
      try {
        const handle = await showSaveFilePicker({
          suggestedName: document.title + '.html',
          types: [{
            description: 'HTML file',
            accept: { 'text/html': ['.html'] },
          }],
        })
        const writable = await handle.createWritable()
        await writable.write(html)
        await writable.close()
        return
      } catch (e) {
        if (e.name === 'AbortError') return
      }
    }

    const blob = new Blob([html], { type: 'text/html' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = document.title + '.html'
    a.click()
    URL.revokeObjectURL(url)
  }

  async function downloadTXT() {
    updateTitle()
    const text = article.textContent

    if ('showSaveFilePicker' in window) {
      try {
        const handle = await showSaveFilePicker({
          suggestedName: document.title + '.txt',
          types: [{
            description: 'TEXT file',
            accept: { 'text/plain': ['.txt'] },
          }],
        })
        const writable = await handle.createWritable()
        await writable.write(text)
        await writable.close()
        return
      } catch (e) {
        if (e.name === 'AbortError') return
      }
    }

    const blob = new Blob([text], { type: 'text/plain' })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = document.title + '.txt'
    a.click()
    URL.revokeObjectURL(url)
  }

  function parseMarkdown(element) {
    const input = element.textContent
    const frag = document.createDocumentFragment()

    const matchers = [
      { name: 'md-codeblock', re: /```[^\n]*\n[\s\S]*?\n```/y },
      { name: 'md-codeblock', re: /~~~[^\n]*\n[\s\S]*?\n~~~/y },
      { name: 'md-h1', re: /^#[ \t]+[^\n]*$/my },
      { name: 'md-h2', re: /^##[ \t]+[^\n]*$/my },
      { name: 'md-h3', re: /^###[ \t]+[^\n]*$/my },
      { name: 'md-h4', re: /^####[ \t]+[^\n]*$/my },
      { name: 'md-h5', re: /^#####[ \t]+[^\n]*$/my },
      { name: 'md-h6', re: /^######[ \t]+[^\n]*$/my },
      { name: 'md-code', re: /`[^`\n]*`/y },
      { name: 'md-bold', re: /\*\*[^*\n]+?\*\*/y },
      { name: 'md-bold', re: /__[^_\n]+?__/y },
      { name: 'md-strike', re: /~~[^~\n]+?~~/y },
      { name: 'md-italic', re: /\*[^*\n]+?\*/y },
      { name: 'md-italic', re: /_[^_\n]+?_/y },
      { name: 'md-url', re: /https?:\/\/[^\s<>()\[\]{}"'`]+/y },
    ]

    const specials = ['`', '~', '*', '#', '_', 'h']

    let i = 0
    while (i < input.length) {
      let matched = false
      for (const m of matchers) {
        m.re.lastIndex = i
        const res = m.re.exec(input)
        if (res && res.index === i) {
          const raw = res[0]
          if (m.name === 'md-url') {
            const a = document.createElement('a')
            a.className = 'md-url'
            a.href = raw
            a.textContent = raw
            a.target = '_blank'
            a.rel = 'noopener noreferrer'
            frag.appendChild(a)
          } else {
            const span = document.createElement('span')
            span.className = m.name
            span.textContent = raw
            frag.appendChild(span)
          }
          i += raw.length
          matched = true
          break
        }
      }

      if (matched) continue

      let next = input.length
      for (const ch of specials) {
        const idx = input.indexOf(ch, i)
        if (idx !== -1 && idx < next) next = idx
      }

      if (next === i) {
        frag.appendChild(document.createTextNode(input[i]))
        i++
        continue
      }

      frag.appendChild(document.createTextNode(input.slice(i, next)))
      i = next
    }

    article.textContent = ''
    article.appendChild(frag)
    article.normalize()
  }

  const notification = document.querySelector('#notification')

  function notify(message) {
    notification.classList.add('visible')
    notification.textContent = message
    setTimeout(() => notification.classList.remove('visible'), 2e3)
  }

  function initUI() {
    // Controls are wired up directly after DOM is ready — nothing to do here
  }

  function ripple(event) {
    const button = event.currentTarget
    const circle = document.createElement('span')
    const diameter = Math.max(button.clientWidth, button.clientHeight)
    const radius = diameter / 2
    circle.style.width = circle.style.height = `${diameter}px`
    circle.style.left = `${(event.clientX || event.targetTouches[0].pageX) - button.offsetLeft - radius}px`
    circle.style.top = `${(event.clientY || event.targetTouches[0].pageY) - button.offsetTop - radius}px`
    circle.classList.add('ripple')
    const ripple = button.getElementsByClassName('ripple')[0]
    if (ripple) ripple.remove()
    button.appendChild(circle)
  }

  function Editor(element, highlight) {
    const listeners = []
    const history = []
    let at = -1, prev

    const debounceHighlight = debounce(30, () => {
      const pos = save()
      highlight(element)
      restore(pos)
    })

    const shouldRecord = (event) => {
      return !isUndo(event) && !isRedo(event)
        && event.key !== 'Meta'
        && event.key !== 'Control'
        && event.key !== 'Alt'
        && !event.key.startsWith('Arrow')
    }

    let recording = false
    const debounceRecordHistory = debounce(300, (event) => {
      if (shouldRecord(event)) {
        recordHistory()
        recording = false
      }
    })

    const on = (type, fn) => {
      listeners.push([type, fn])
      element.addEventListener(type, fn)
    }
    on('keydown', event => {
      if (event.defaultPrevented) return
      prev = toString()
      if (isUndo(event)) doUndo(event)
      if (isRedo(event)) doRedo(event)
      if (shouldRecord(event) && !recording) {
        recordHistory()
        recording = true
      }
    })
    on('keyup', event => {
      if (event.defaultPrevented) return
      if (event.isComposing) return
      if (prev !== toString()) debounceHighlight()
      debounceRecordHistory(event)
    })
    on('paste', () => setTimeout(recordHistory, 10))
    on('cut', () => setTimeout(recordHistory, 10))
    on('beforeinput', event => {
      if (event.inputType === 'historyUndo') doUndo(event)
      if (event.inputType === 'historyRedo') doRedo(event)
    })

    function save() {
      const s = getSelection()
      const pos = { start: 0, end: 0, dir: undefined }
      let { anchorNode, anchorOffset, focusNode, focusOffset } = s
      if (!anchorNode || !focusNode) throw 'error1'
      if (anchorNode === element && focusNode === element) {
        pos.start = (anchorOffset > 0 && element.textContent) ? element.textContent.length : 0
        pos.end = (focusOffset > 0 && element.textContent) ? element.textContent.length : 0
        pos.dir = (focusOffset >= anchorOffset) ? '->' : '<-'
        return pos
      }
      if (anchorNode.nodeType === Node.ELEMENT_NODE) {
        const node = document.createTextNode('')
        anchorNode.insertBefore(node, anchorNode.childNodes[anchorOffset])
        anchorNode = node
        anchorOffset = 0
      }
      if (focusNode.nodeType === Node.ELEMENT_NODE) {
        const node = document.createTextNode('')
        focusNode.insertBefore(node, focusNode.childNodes[focusOffset])
        focusNode = node
        focusOffset = 0
      }
      visit(element, el => {
        if (el === anchorNode && el === focusNode) {
          pos.start += anchorOffset
          pos.end += focusOffset
          pos.dir = anchorOffset <= focusOffset ? '->' : '<-'
          return 'stop'
        }
        if (el === anchorNode) {
          pos.start += anchorOffset
          if (!pos.dir) {
            pos.dir = '->'
          } else {
            return 'stop'
          }
        } else if (el === focusNode) {
          pos.end += focusOffset
          if (!pos.dir) {
            pos.dir = '<-'
          } else {
            return 'stop'
          }
        }
        if (el.nodeType === Node.TEXT_NODE) {
          if (pos.dir !== '->') pos.start += el.nodeValue.length
          if (pos.dir !== '<-') pos.end += el.nodeValue.length
        }
      })

      element.normalize()
      return pos
    }

    function restore(pos) {
      const s = getSelection()
      let startNode, startOffset = 0
      let endNode, endOffset = 0

      if (!pos.dir) pos.dir = '->'
      if (pos.start < 0) pos.start = 0
      if (pos.end < 0) pos.end = 0

      if (pos.dir === '<-') {
        const { start, end } = pos
        pos.start = end
        pos.end = start
      }

      let current = 0

      visit(element, el => {
        if (el.nodeType !== Node.TEXT_NODE) return

        const len = (el.nodeValue || '').length
        if (current + len > pos.start) {
          if (!startNode) {
            startNode = el
            startOffset = pos.start - current
          }
          if (current + len > pos.end) {
            endNode = el
            endOffset = pos.end - current
            return 'stop'
          }
        }
        current += len
      })

      if (!startNode) {
        startNode = element
        startOffset = element.childNodes.length
      }
      if (!endNode) {
        endNode = element
        endOffset = element.childNodes.length
      }

      if (pos.dir === '<-') {
        [startNode, startOffset, endNode, endOffset] = [endNode, endOffset, startNode, startOffset]
      }

      {
        const startEl = uneditable(startNode)
        if (startEl) {
          const node = document.createTextNode('')
          startEl.parentNode?.insertBefore(node, startEl)
          startNode = node
          startOffset = 0
        }
        const endEl = uneditable(endNode)
        if (endEl) {
          const node = document.createTextNode('')
          endEl.parentNode?.insertBefore(node, endEl)
          endNode = node
          endOffset = 0
        }
      }

      s.setBaseAndExtent(startNode, startOffset, endNode, endOffset)
      element.normalize()
    }

    function uneditable(node) {
      while (node && node !== element) {
        if (node.nodeType === Node.ELEMENT_NODE) {
          if (node.getAttribute('contenteditable') === 'false') {
            return node
          }
        }
        node = node.parentNode
      }
    }

    function doUndo(event) {
      preventDefault(event)
      at--
      const record = history[at]
      if (record) {
        element.innerHTML = record.html
        restore(record.pos)
      }
      if (at < 0) at = 0
    }

    function doRedo(event) {
      preventDefault(event)
      at++
      const record = history[at]
      if (record) {
        element.innerHTML = record.html
        restore(record.pos)
      }
      if (at >= history.length) at--
    }

    function recordHistory() {
      const html = element.innerHTML
      const pos = save()
      const lastRecord = history[at]
      if (
        lastRecord
        && lastRecord.html === html
        && lastRecord.pos.start === pos.start
        && lastRecord.pos.end === pos.end
      ) return
      at++
      history[at] = { html, pos }
      history.splice(at + 1)
      const maxHistory = 10_000
      if (at > maxHistory) {
        at = maxHistory
        history.splice(0, 1)
      }
    }

    function visit(editor, visitor) {
      const queue = []
      if (editor.firstChild) queue.push(editor.firstChild)
      let el = queue.pop()
      while (el) {
        if (visitor(el) === 'stop') break
        if (el.nextSibling) queue.push(el.nextSibling)
        if (el.firstChild) queue.push(el.firstChild)
        el = queue.pop()
      }
    }

    function isCtrl(event) {
      return event.metaKey || event.ctrlKey
    }

    function isUndo(event) {
      return isCtrl(event) && !event.shiftKey && event.code === 'KeyZ'
    }

    function isRedo(event) {
      return isCtrl(event) && event.shiftKey && event.code === 'KeyZ'
    }

    function toString() {
      return element.textContent || ''
    }

    function preventDefault(event) {
      event.preventDefault()
    }

    function getSelection() {
      return element.getRootNode().getSelection()
    }

    return {
      set(content) {
        element.textContent = content
        highlight(element)
      },
      destroy() {
        for (const [type, fn] of listeners) editor.removeEventListener(type, fn)
      },
    }
  }
</script>
<svg style="display: none" aria-hidden="true" focusable="false">
  <symbol id="icon-plus" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.25"
    stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-plus">
    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
    <path d="M12 5l0 14" />
    <path d="M5 12l14 0" />
  </symbol>
  <symbol id="icon-share" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.25"
    stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
    <path d="M8 9h-1a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-8a2 2 0 0 0 -2 -2h-1" />
    <path d="M12 14v-11" />
    <path d="M9 6l3 -3l3 3" />
  </symbol>
  <symbol id="icon-qrcode" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.25"
    stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
    <path d="M4 5a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1l0 -4" />
    <path d="M7 17l0 .01" />
    <path d="M14 5a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1l0 -4" />
    <path d="M7 7l0 .01" />
    <path d="M4 15a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1l0 -4" />
    <path d="M17 7l0 .01" />
    <path d="M14 14l3 0" />
    <path d="M20 14l0 .01" />
    <path d="M14 14l0 3" />
    <path d="M14 20l3 0" />
    <path d="M17 17l3 0" />
    <path d="M20 17l0 3" />
  </symbol>
  <symbol id="icon-github" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.25"
    stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
    <path
      d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
  </symbol>
  <symbol id="icon-empty" viewBox="0 0 24 24"></symbol>
</svg>